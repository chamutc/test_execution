1. cập nhật lại csv file thêm cột Mode, mặc định nếu không có cột này hoặc rỗng thì mode của session sẽ là NA,
2. thay đổi lại cách quản lý hardware, trong phần quản lý hardware sẽ chia làm 3 phần:
- danh sách hardware cần được lấy từ table session (combination: debugger, board, mode)
- hardware trong inventory: quản lý các hardware đang có sẵn ở kho, cho phép quản lý số lượng board, debugger đang có (data sẽ tự động lấy từ file csv khi import - tự động add thêm debugger name, board name nếu chưa có trong kho), quản lý về số lượng của từng loại
- hardware combination: quản lý các combination của hardware (debugger, board, mode), cho phép user tạo ra các combination thể hiện các combination đang được setup thực tế (cần dựa vào số lượng đang có của từng loại: board, debugger ở trong kho để validate, không cho phép chọn nhiều hơn số đang có ở trong kho, ví dụ nếu board đã được dùng hết thì debugger còn cũng không sử dụng được, mode là option cho phép user nhập vào, default là NA), mỗi hardware này sẽ là 1 đối tượng duy nhất (cho thêm mode clone để clone combination ra cho nhanh), trong table này sẽ implement thêm 1 chức năng là thời gian đã được allocate cho các session nào và thời gian còn lại cho phép sử dụng (số lượng thời gian còn lại = số lượng thời gian của hardware - tổng thời gian đã được allocate cho các session) mặc định lúc khởi tạo thời gian available sẽ là 24h, nhưng cho phép user điều chỉnh theo từng combination, từng slot time availeble cho 1 hardware cụ thể, khi user click edit thì sẽ hiển thị ra 1 table cho phép user nhập vào thời gian available cho từng slot time (giờ nào có thể sử dụng, giờ nào không thể sử dụng), ở từng combination sẽ có thêm 1 cột multiple value là platform supported: mục này thể hiện việc combination này có thể chạy được cho request với board (platform nào), mặc định giá trị sẽ là giá trị ở cột board và cho phép user add thêm các giá trị khác (cho phép add thêm nhiều giá trị, các giá trị suggest ở đây là board name (platform))

các chức năng này cần có API để có thể truy vấn và update thông tin từ frontend
3. Chức năng timeline scheduling: 
- implement button clear schedule để clear toàn bộ các session đã schedule thành pending
- update button auto schedule: concurrent build sẽ được tự động sắp xếp dựa trên máy + hardware available tại thời điểm schedule
- implement thêm cơ chế queue mô phỏng lại rabbitmq hoặc có thể dùng trực tiếp luôn:
+ các session cần chạy sẽ được đưa vào queue theo thứ tự ưu tiên (sẽ có 1 slot show toàn bộ các session nằm trong queue - các session ở trạng thái pending sẽ ở đây)
+ khi nhấn vào nut auto schedule theo từng chiến lược khác nhau (đã được định nghĩa ở trước đó) thì tool sẽ kiểm tra xem máy + mạch đang availe như nào và sắp xếp các session trong queue vào các slot có thể chạy được (các session đã được sắp xếp sẽ được move ra khỏi queue và vào trạng thái scheduled), quá trình này nên có delay khoảng 2s cho mỗi lần sắp xếp để có thể quan sát được các session đang đưa dần vào các slot (việc lựa chọn slot nào sẽ phụ thuộc vào slot availe trên OS phù hợp với session, board đang available (cần kiểm tra xem trong thời gian start/end của session có còn board nào available phù hợp với session không - cần check board/debugger/mode để đưa ra board phù hợp với. session - sẽ so sánh phần này với table hardware combination)), khi session sử dụng hardware thì cần update lại table hardware combination để đảm bảo session khác không sử dụng hardware đó trong thời gian session này chiếm dụng (hardware combination có thể trả về nhiều hơn 1 giá trị do nó có nhiều hơn 1 board), để so sánh xem session có phụ hợp chạy trên 1 combination cụ thể nào thì cần kiểm tra board có map với platform supported của combination không, debugger của combination có trùng với debugger của session không, mode của combination có trùng với mode của session không (nếu session không có mode thì mặc định là NA và sẽ khớp với tất cả các combination), nếu session không có Debuuger thì không cần quan tâm đến hardware chỉ cần có slot availe tương ứng với os thì có thể sắp xếp vào slot đó

I need to implement several major enhancements to the Jenkins Test Scheduler system. Please implement these changes in the following order:

## 1. CSV Import Enhancement - Add Mode Column

**Requirement**: Update the CSV processing to support a new "Mode" column
- **Backend Changes**:
  - Modify `backend/services/csvProcessor.js` to recognize and process a "Mode" column
  - If Mode column is missing or empty, default the session's mode to "NA"
  - Update session data structure to include the mode field
- **Frontend Changes**:
  - Update CSV import preview to show the Mode column
  - Update Sessions table to display the Mode column

## 2. Hardware Management System Redesign

**Requirement**: Completely restructure hardware management into 3 distinct sections:

### 2.1 Hardware Requirements (Read-Only)
- **Purpose**: Display unique hardware combinations required by sessions
- **Data Source**: Extract unique combinations of (debugger, board, mode) from all sessions
- **Display**: Read-only table showing what hardware combinations are needed
- **API Endpoints**: 
  - `GET /api/hardware/requirements` - Get unique combinations from sessions

### 2.2 Hardware Inventory Management
- **Purpose**: Manage physical hardware stock in warehouse
- **Features**:
  - Track quantities of individual components (boards, debuggers)
  - Auto-populate from CSV imports (add new debugger/board names if not in inventory)
  - CRUD operations for inventory items with quantity management
- **Data Structure**:
  ```json
  {
    "id": "uuid",
    "type": "board|debugger", 
    "name": "string",
    "quantity": "number",
    "available": "number"
  }
  ```
- **API Endpoints**:
  - `GET /api/hardware/inventory` - Get all inventory items
  - `POST /api/hardware/inventory` - Add inventory item
  - `PUT /api/hardware/inventory/:id` - Update inventory item
  - `DELETE /api/hardware/inventory/:id` - Remove inventory item

### 2.3 Hardware Combinations Management
- **Purpose**: Manage actual hardware setups (physical combinations)
- **Features**:
  - Create combinations of (debugger, board, mode)
  - Validate against inventory quantities (cannot exceed available stock)
  - Clone combinations for quick setup
  - Time allocation tracking (24h default, user-configurable)
  - Hourly availability scheduling (which hours each combination is usable)
  - Platform support mapping (which platforms each combination supports)
- **Data Structure**:
  ```json
  {
    "id": "uuid",
    "name": "string",
    "debugger": "string",
    "board": "string", 
    "mode": "string (default: NA)",
    "platformsSupported": ["string"], // defaults to [board], user can add more
    "totalAvailableHours": 24,
    "hourlyAvailability": {
      "0": true, "1": true, ... "23": true
    },
    "allocatedTime": "number", // calculated from scheduled sessions
    "remainingTime": "number"  // totalAvailableHours - allocatedTime
  }
  ```
- **UI Features**:
  - Combination CRUD with inventory validation
  - Clone button for quick duplication
  - Edit availability: Modal with 24-hour grid for enabling/disabling time slots
  - Platform support: Multi-select dropdown with board names as suggestions
- **API Endpoints**:
  - `GET /api/hardware/combinations` - Get all combinations
  - `POST /api/hardware/combinations` - Create combination (with inventory validation)
  - `PUT /api/hardware/combinations/:id` - Update combination
  - `DELETE /api/hardware/combinations/:id` - Remove combination
  - `POST /api/hardware/combinations/:id/clone` - Clone combination
  - `PUT /api/hardware/combinations/:id/availability` - Update hourly availability

## 3. Timeline Scheduling Enhancements

### 3.1 Clear Schedule Function
- **Requirement**: Add "Clear Schedule" button to reset all scheduled sessions to pending
- **Implementation**: 
  - Button in Timeline header
  - Confirmation dialog
  - API endpoint: `DELETE /api/scheduling/clear`
  - Reset all sessions with status "scheduled" back to "pending"

### 3.2 Enhanced Auto-Schedule
- **Requirement**: Improve auto-scheduling to consider machine + hardware availability
- **Logic**: 
  - Check both machine availability AND hardware combination availability
  - Match session requirements (platform, debugger, mode) with available combinations
  - Consider time slot availability for each hardware combination

### 3.3 Queue Management System
- **Requirement**: Implement visual queue system for pending sessions
- **Features**:
  - Queue panel showing all pending sessions ordered by priority
  - Visual scheduling process with 2-second delays between placements
  - Real-time updates as sessions move from queue to scheduled
  - Different scheduling strategies (priority-first, time-optimized, etc.)
- **Matching Logic**:
  - **Platform Match**: Session platform must be in combination's platformsSupported array
  - **Debugger Match**: Session debugger must match combination debugger (if session has debugger)
  - **Mode Match**: Session mode must match combination mode (NA matches all)
  - **No Debugger**: If session has no debugger requirement, only check machine OS compatibility
  - **Time Availability**: Check combination's hourly availability for session duration
  - **Hardware Allocation**: Update combination's allocated time when session is scheduled
- **API Endpoints**:
  - `GET /api/scheduling/queue` - Get pending sessions queue
  - `POST /api/scheduling/auto-schedule` - Enhanced auto-scheduling with hardware awareness
  - `GET /api/scheduling/strategies` - Get available scheduling strategies

## Implementation Priority:
1. CSV Mode column support
2. Hardware Inventory management
3. Hardware Combinations management  
4. Hardware Requirements display
5. Timeline Clear Schedule button
6. Enhanced Auto-Schedule with hardware awareness
7. Queue management system

Please implement comprehensive error handling, input validation, and real-time updates via WebSocket for all new features.